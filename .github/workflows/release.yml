name: Release

on:
  push:
    branches:
      - main
      - master

permissions:
  contents: write
  issues: write
  pull-requests: write
  id-token: write

jobs:
  release-please:
    runs-on: ubuntu-latest
    outputs:
      release_created: ${{ steps.release.outputs.release_created }}
      tag_name: ${{ steps.release.outputs.tag_name }}
    steps:
      - uses: googleapis/release-please-action@v4
        id: release
        with:
          token: ${{ secrets.SUBSCRIPTION_API_RELEASE_PLEASE_TOKEN }}
          release-type: python

      - name: Remove source code assets
        if: ${{ steps.release.outputs.release_created }}
        env:
          GH_TOKEN: ${{ secrets.SUBSCRIPTION_API_RELEASE_PLEASE_TOKEN }}
        run: |
          TAG="${{ steps.release.outputs.tag_name }}"
          REPO="${{ github.repository }}"
          # List and delete all .zip and .tar.gz assets
          gh release view "$TAG" --repo "$REPO" --json assets -q '.assets[].name' | while read -r asset; do
            if [[ "$asset" == *.zip ]] || [[ "$asset" == *.tar.gz ]]; then
              echo "Deleting $asset"
              gh release delete-asset "$TAG" "$asset" --repo "$REPO" --yes || true
            fi
          done

  build-and-push:
    needs: release-please
    if: ${{ needs.release-please.outputs.release_created }}
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
          IMAGE_TAG: ${{ needs.release-please.outputs.tag_name }}
        run: |
          docker build -f api/Dockerfile.lambda -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./api
          docker build -f api/Dockerfile.lambda -t $ECR_REGISTRY/$ECR_REPOSITORY:latest ./api
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
          echo "Pushed $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
          echo "Pushed $ECR_REGISTRY/$ECR_REPOSITORY:latest"

      # - name: Update Lambda functions to use new image
      #   if: steps.changes.outputs.api == 'true'
      #   env:
      #     ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      #     ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      #     IMAGE_TAG: ${{ needs.release-please.outputs.tag_name }}
      #   run: |
      #     IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      #     # Update API Lambda
      #     aws lambda update-function-code \
      #       --function-name shade-subscription-api-staging \
      #       --image-uri "$IMAGE_URI"

      #     # Update Migration Lambda
      #     aws lambda update-function-code \
      #       --function-name shade-subscription-api-staging-migrate \
      #       --image-uri "$IMAGE_URI"

      #     # Wait for updates to complete
      #     aws lambda wait function-updated --function-name shade-subscription-api-staging
      #     aws lambda wait function-updated --function-name shade-subscription-api-staging-migrate

      # - name: Run database migrations
      #   if: steps.changes.outputs.api == 'true'
      #   run: |
      #     aws lambda invoke \
      #       --function-name shade-subscription-api-staging-migrate \
      #       --payload '{"revision": "head"}' \
      #       --cli-binary-format raw-in-base64-out \
      #       response.json

      #     echo "Migration response:"
      #     cat response.json

      #     # Check if migration was successful
      #     if grep -q '"statusCode": 500' response.json; then
      #       echo "Migration failed!"
      #       exit 1
      #     fi

  deploy:
    needs: [release-please, build-and-push]
    if: ${{ needs.release-please.outputs.release_created }}
    runs-on: ubuntu-latest
    environment: staging
    env:
      TF_VAR_environment: staging
      TF_VAR_route53_zone_id: ${{ secrets.ROUTE53_ZONE_ID }}
      TF_VAR_mariadb_db_name: ${{ secrets.MARIADB_DB_NAME }}
      TF_VAR_mariadb_db_username: ${{ secrets.MARIADB_DB_USERNAME }}
      TF_VAR_mariadb_db_password: ${{ secrets.MARIADB_DB_PASSWORD }}
      TF_VAR_vpc_id: ${{ secrets.VPC_ID }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ">=1.14.0"

      - name: Terraform Init
        working-directory: terraform/${{ env.TF_VAR_environment }}
        run: terraform init

      - name: Terraform Plan
        run: make tf-plan

      - name: Terraform Apply
        run: make tf-apply

      - name: Run database migrations
        run: make migrate-lambda
